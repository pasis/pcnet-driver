[Описание]

2.1 Регистрация драйвера PCI устройства

Vendor ID у AMD равен 0x1022, а Device ID сетевой карты - 0x2000. Эти значения
объявлены в <linux/pci_ids.h> как PCI_VENDOR_ID_AMD и PCI_DEVICE_ID_AMD_LANCE
соответственно.

Для заполнения структуры pci_device_id можно воспользоваться макросом
PCI_DEVICE, который объявлен в <linux/pci.h>. Этот макрос подставляет значение
vendor и device в структуру, а значения subvendor и subdevice устанавливает в
PCI_ANY_ID. Использование в нашем случае:
	struct pci_device_id pcnet_pci_tbl[] =
	{
		{ PCI_DEVICE( PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LANCE ), },
		{ }
	}	  

pci_driver - это структура, описывающая драйвер PCI устройства [2]. Минимально
необходимый набор полей структуры приведен ниже.
	struct pci_driver pcnet_pci_driver =
	{
		.name		= DRV_NAME,
		.id_table	= pcnet_dummy_pci_tbl,
		.probe		= pcnet_dummy_init_one,
		.remove		= __devexit_p(pcnet_dummy_remove_one),
	};

По id_table код PCI core вызывает функцию инициализации драйвера
(.probe = pcnet_dummy_init_one ). name является указателем на строку с именем.
Прототипы функций probe() и remove() можно посмотреть в описании структуры
pci_driver в <linux/pci.h>.

Регистрацию драйвера PCI устройства лучше всего выполнять внутри функции
инициализации модуля:
	pci_register_driver(&pcnet_pci_driver);

Функции инициализации и очистки необходимо "пометить атрибутами", макросы
определены в <linux/init.h> [2]. Для функций инициализации и очистки модуля
необходимо использовать __init и __exit соответственно, а для инициализации и
очистки устройства - __devinit и __devexit. Функции, вызываемые из probe()
также можно пометить __devinit. Как говорится в [2], лучше не помечать
функции, чем пометить неправильно.
Таблица pcnet_pci_tbl должна быть отмечена как __devinitconst [2], но это
делается автоматически, если таблица объявлена через DEFINE_PCI_DEVICE_TABLE()


2.2 Инициализация устройства

Перед тем как работать с регистрами, необходимо выполнить pci_enable_device().
Это выполнит следующие действия [2]:
 - "пробуждение" устройства
 - выделение ресурсов, если этого не сделал BIOS

Bus mastering [3]
 Bus mastering (Управление шиной) это функция шины PCI которая может
 использоваться любым PCI устройством (например контроллером диска,
 графическим контроллером или звуковой картой). Bus mastering позволяет
 устройству управлять шиной и осуществлять (инициировать) любые транзакции
 чтения / записи к другим устройствам на шине PCI или к системной памяти. Эти
 транзакции осуществляются независимо от главного процессора, поэтому они
 отнимают время только у шины, но не у процессора. Bus mastering транзакции
 нисколько не быстрее обычных транзакций, осуществляемых процессором.
 Преимущество bus mastering в том, что контроллер запрограммированный на
 выполнение какой-либо передачи данных или на выполнение последовательности
 команд больше не требует действий от процессора пока он (контроллер) не
 завершит свою задачу. Обычно для информирования процессора о том, что хозяин
 шины (bus master) выполнил свои действия используется механизм прерываний.

Драйвера должны вызывать pci_release_region() после вызова
pci_disable_device() [2].

Для включения функции bus mastering для pci устройства, используется функция
pci_set_master().

В <linux/pci.h> объявлены макросы, которые выбирают из структуры pci_dev
начальный адрес I/O, конечный, размер этого адресного пространства и флаги.
Эти макросы лишь облегчают написание и понимание кода. На самом деле они
заменяются на обращение к полю resource. Получение начального адреса выглядит:
	ioaddr = pci_resource_start(pdev, 0);

[Литература]

1. Клаус Вейрле и др. "Linux. Сетевая архитектура. Структура и реализация
                       сетевых протоколов в ядре"
2. Documentation/PCI/pci.txt
3. "Руководство по PCI и AGP" http://www.3dnews.ru/video/pci-agp-guide/print
4. http://yarchive.net/comp/linux/io_space_accesses.html

